package ft.team1.se21.ui;

import java.awt.Dimension;
import java.util.HashMap;

import javax.swing.DefaultCellEditor;
import javax.swing.GroupLayout;
import javax.swing.JComboBox;
import javax.swing.JFrame;
import javax.swing.JScrollBar;
import javax.swing.JScrollPane;
import javax.swing.JTable;
import javax.swing.LayoutStyle;
import javax.swing.table.AbstractTableModel;
import javax.swing.table.DefaultTableCellRenderer;
import javax.swing.table.TableColumn;

import ft.team1.se21.manager.InventoryManager;
import ft.team1.se21.model.PurchaseOrder;

public class VendorSelectionUI extends JFrame {

  /**
	 * 
	 */
	private static final long serialVersionUID = 1L;
	/* private JComboBox samir; */
	private JScrollBar verticalScrollBar;
	private JScrollBar horizontalScrollBar;
	private JScrollPane scrollPane;
	private JTable vendorTable;
	private InventoryManager invManager = new InventoryManager();
	private HashMap<String,PurchaseOrder> po = new HashMap<String,PurchaseOrder>();
	/**
	 * Creates new form VendorSelectionUI
	 */
	public VendorSelectionUI(InventoryManager iManager, HashMap<String,PurchaseOrder> po) {
		this.invManager = iManager;
		this.po = po;
		initComponents();
		this.setVisible(true);
	}

	/**
	 * This method is called from within the constructor to initialize the form.
	 * WARNING: Do NOT modify this code. The content of this method is always
	 * regenerated by the Form Editor.
	 */

	private void initComponents() {

		vendorTable = new JTable(new CustomTableModel());
		vendorTable.setPreferredScrollableViewportSize(new Dimension(400, 70));
		vendorTable.setFillsViewportHeight(true);
		verticalScrollBar = new JScrollBar();
		horizontalScrollBar = new JScrollBar();
		scrollPane = new JScrollPane(vendorTable);
		setUpVendorSelectionColumn(vendorTable, vendorTable.getColumnModel().getColumn(1));

		/* samir.setVisible(true); */
		horizontalScrollBar.setOrientation(JScrollBar.HORIZONTAL);
		scrollPane.setViewportView(vendorTable);

		GroupLayout layout = new GroupLayout(getContentPane());
		getContentPane().setLayout(layout);
		layout.setHorizontalGroup(layout
				.createParallelGroup(GroupLayout.Alignment.TRAILING)
				.addGroup(
						layout.createSequentialGroup()
								.addComponent(scrollPane,
										GroupLayout.PREFERRED_SIZE,
										551,
										GroupLayout.PREFERRED_SIZE)
								.addPreferredGap(
										LayoutStyle.ComponentPlacement.RELATED,
										GroupLayout.DEFAULT_SIZE,
										Short.MAX_VALUE)
								.addComponent(verticalScrollBar,
										GroupLayout.PREFERRED_SIZE,
										GroupLayout.DEFAULT_SIZE,
										GroupLayout.PREFERRED_SIZE))
				.addGroup(
						layout.createSequentialGroup()
								.addComponent(horizontalScrollBar,
										GroupLayout.DEFAULT_SIZE,
										GroupLayout.DEFAULT_SIZE,
										Short.MAX_VALUE).addContainerGap()));
		layout.setVerticalGroup(layout
				.createParallelGroup(GroupLayout.Alignment.LEADING)
				.addGroup(
						layout.createSequentialGroup()
								.addGroup(
										layout.createParallelGroup(
												GroupLayout.Alignment.TRAILING)
												.addComponent(
														verticalScrollBar,
														GroupLayout.PREFERRED_SIZE,
														243,
														GroupLayout.PREFERRED_SIZE)
												.addComponent(
														scrollPane,
														GroupLayout.PREFERRED_SIZE,
														253,
														GroupLayout.PREFERRED_SIZE))
								.addPreferredGap(
										LayoutStyle.ComponentPlacement.RELATED,
										GroupLayout.DEFAULT_SIZE,
										Short.MAX_VALUE)
								.addComponent(horizontalScrollBar,
										GroupLayout.PREFERRED_SIZE,
										GroupLayout.DEFAULT_SIZE,
										GroupLayout.PREFERRED_SIZE)));

		pack();
	}// </editor-fold>

	
	class CustomTableModel extends AbstractTableModel {

		/**
		 * 
		 */
		private static final long serialVersionUID = 1L;
		private String[] columnNames = { "Category", "Vendor"};
		private Object[][] data = {
				{ "Mug", "Snowboarding"},
				{ "Clothing", "Rowing"},
				{ "Stationary", "Knitting"}};
				
		public final Object[] longValues = { "Jane", "None of the above"};

		public int getColumnCount() {
			return columnNames.length;
		}

		public int getRowCount() {
			return data.length;
		}

		public String getColumnName(int col) {
			return columnNames[col];
		}

		public Object getValueAt(int row, int col) {
			return data[row][col];
		}

		/*
		 * JTable uses this method to determine the default renderer/ editor for
		 * each cell. If we didn't implement this method, then the last column
		 * would contain text ("true"/"false"), rather than a check box.
		 */
		public Class getColumnClass(int c) {
			return getValueAt(0, c).getClass();
		}

		/*
		 * Don't need to implement this method unless your table's editable.
		 */
		public boolean isCellEditable(int row, int col) {
			// Note that the data/cell address is constant,
			// no matter where the cell appears onscreen.
			if (col < 2) {
				return false;
			} else {
				return true;
			}
		}

		/*
		 * Don't need to implement this method unless your table's data can
		 * change.
		 */
		public void setValueAt(Object value, int row, int col) {
			data[row][col] = value;
			fireTableCellUpdated(row, col);
		}

	}

	public void setUpVendorSelectionColumn(JTable table, TableColumn sportColumn) {
		// Set up the editor for the sport cells.
		JComboBox comboBox = new JComboBox();
		comboBox.addItem("Snowboarding");
		comboBox.addItem("Rowing");
		comboBox.addItem("Knitting");
		comboBox.addItem("Speed reading");
		comboBox.addItem("Pool");
		comboBox.addItem("None of the above");
		sportColumn.setCellEditor(new DefaultCellEditor(comboBox));

		// Set up tool tips for the sport cells.
		DefaultTableCellRenderer renderer = new DefaultTableCellRenderer();
		renderer.setToolTipText("Click for combo box");
		sportColumn.setCellRenderer(renderer);
	}
}
